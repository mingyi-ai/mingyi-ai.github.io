<!DOCTYPE html>
<html lang="en" dir="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Numerical Methods for Hermite Polynomials | Mingyi&#39;s Page</title>
<meta name="keywords" content="Hermite Polynomials, Numerical Methods">
<meta name="description" content="In this post, we will explore the numerics of Hermite polynomials, as part of a numerical solver project for Kramers hyperbolic system. In particular, we try to compute eigenvectors numerically for the Hermite generating matrix, which is a tridiagonal matrix given by the recurrence relation
$$
x \mathrm{H}_{n}(x) = \sqrt{n&#43;1} \mathrm{H}_{n&#43;1}(x) - \sqrt{n} \mathrm{H}_{n-1}(x)
$$for \( n \geq 1 \) with \(\mathrm{H}_{n}(x)\) being the \(n\)-th normalized Hermite polynomial.
The generating matrix is given by">
<meta name="author" content="Mingyi Hou">
<link rel="canonical" href="http://localhost:1313/posts/25-05-02_hermite-numerics/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.2414f36f416064caac078a7b15214f4b880bd045e9839f72a7ddcb4a8d0a3062.css" integrity="sha256-JBTzb0FgZMqsB4p7FSFPS4gL0EXpg59yp93LSo0KMGI=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://localhost:1313/apple-touch-icon.png">
<link rel="mask-icon" href="http://localhost:1313/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="http://localhost:1313/posts/25-05-02_hermite-numerics/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/katex.min.css" integrity="sha384-zh0CIslj+VczCZtlzBcjt5ppRcsAmDnRem7ESsYwWwg3m/OaJ2l4x7YBZl9Kxxib" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/katex.min.js" integrity="sha384-Rma6DA2IPUwhNxmrB/7S3Tno0YY7sFu9WSYMCuulLhIqYSGZ2gKCJWIqhBWqMQfh" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/contrib/auto-render.min.js" integrity="sha384-hCXGrW6PitJEwbkoStFjeJxv+fSOOQKOPbJxSfM6G5sWZjAyWhXiTIIAmQqnlLlh" crossorigin="anonymous"></script>
<script>
    document.addEventListener("DOMContentLoaded", function() {
        renderMathInElement(document.body, {
          
          
          delimiters: [
              {left: '$$', right: '$$', display: true},
              {left: '$', right: '$', display: false},
              {left: '\\(', right: '\\)', display: false},
              {left: '\\[', right: '\\]', display: true}
          ],
          
          throwOnError : false
        });
    });
</script>

<meta property="og:url" content="http://localhost:1313/posts/25-05-02_hermite-numerics/">
  <meta property="og:site_name" content="Mingyi&#39;s Page">
  <meta property="og:title" content="Numerical Methods for Hermite Polynomials">
  <meta property="og:description" content="In this post, we will explore the numerics of Hermite polynomials, as part of a numerical solver project for Kramers hyperbolic system. In particular, we try to compute eigenvectors numerically for the Hermite generating matrix, which is a tridiagonal matrix given by the recurrence relation
$$ x \mathrm{H}_{n}(x) = \sqrt{n&#43;1} \mathrm{H}_{n&#43;1}(x) - \sqrt{n} \mathrm{H}_{n-1}(x) $$for \( n \geq 1 \) with \(\mathrm{H}_{n}(x)\) being the \(n\)-th normalized Hermite polynomial. The generating matrix is given by">
  <meta property="og:locale" content="en-us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2025-05-02T00:00:00+00:00">
    <meta property="article:modified_time" content="2025-05-02T00:00:00+00:00">
    <meta property="article:tag" content="Hermite Polynomials">
    <meta property="article:tag" content="Numerical Methods">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Numerical Methods for Hermite Polynomials">
<meta name="twitter:description" content="In this post, we will explore the numerics of Hermite polynomials, as part of a numerical solver project for Kramers hyperbolic system. In particular, we try to compute eigenvectors numerically for the Hermite generating matrix, which is a tridiagonal matrix given by the recurrence relation
$$
x \mathrm{H}_{n}(x) = \sqrt{n&#43;1} \mathrm{H}_{n&#43;1}(x) - \sqrt{n} \mathrm{H}_{n-1}(x)
$$for \( n \geq 1 \) with \(\mathrm{H}_{n}(x)\) being the \(n\)-th normalized Hermite polynomial.
The generating matrix is given by">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "http://localhost:1313/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Numerical Methods for Hermite Polynomials",
      "item": "http://localhost:1313/posts/25-05-02_hermite-numerics/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Numerical Methods for Hermite Polynomials",
  "name": "Numerical Methods for Hermite Polynomials",
  "description": "In this post, we will explore the numerics of Hermite polynomials, as part of a numerical solver project for Kramers hyperbolic system. In particular, we try to compute eigenvectors numerically for the Hermite generating matrix, which is a tridiagonal matrix given by the recurrence relation\n$$ x \\mathrm{H}_{n}(x) = \\sqrt{n+1} \\mathrm{H}_{n+1}(x) - \\sqrt{n} \\mathrm{H}_{n-1}(x) $$for \\( n \\geq 1 \\) with \\(\\mathrm{H}_{n}(x)\\) being the \\(n\\)-th normalized Hermite polynomial. The generating matrix is given by\n",
  "keywords": [
    "Hermite Polynomials", "Numerical Methods"
  ],
  "articleBody": "In this post, we will explore the numerics of Hermite polynomials, as part of a numerical solver project for Kramers hyperbolic system. In particular, we try to compute eigenvectors numerically for the Hermite generating matrix, which is a tridiagonal matrix given by the recurrence relation\n$$ x \\mathrm{H}_{n}(x) = \\sqrt{n+1} \\mathrm{H}_{n+1}(x) - \\sqrt{n} \\mathrm{H}_{n-1}(x) $$for \\( n \\geq 1 \\) with \\(\\mathrm{H}_{n}(x)\\) being the \\(n\\)-th normalized Hermite polynomial. The generating matrix is given by\n$$ \\mathrm{T}_n = \\begin{pmatrix} 0 \u0026 \\sqrt{1} \u0026 0 \u0026 \\cdots \u0026 \\cdots \\\\ \\sqrt{1} \u0026 0 \u0026 \\sqrt{2} \u0026 \\cdots \u0026 \\cdots \\\\ 0 \u0026 \\sqrt{2} \u0026 \\ddots \u0026 \\cdots \u0026 \\cdots \\\\ \\vdots \u0026 \\vdots \u0026 \\vdots \u0026 0 \u0026 \\sqrt{n-1} \\\\ \\vdots \u0026 \\vdots \u0026 \\vdots \u0026 \\sqrt{n-1} \u0026 0 \\end{pmatrix}. $$All the codes below are implemented in Julia.\nTheoretical eigenvalues and eigenvectors Recall that the Hermite polynomials are defined by\n$$ \\mathrm{He}_n(x) = (-1)^n \\exp(x^2/2) \\frac{\\mathrm{d}^n}{\\mathrm{d}x^n} \\left( \\exp(-x^2/2) \\right) $$for $n \\geq 0$. The first few Hermite polynomials are given by\n$$ \\mathrm{He}_0(x) = 1, \\\\ \\mathrm{He}_1(x) = x, \\\\ \\mathrm{He}_2(x) = x^2 - 1, \\\\ \\mathrm{He}_3(x) = x^3 - 3x. $$The Hermite polynomials can be computed using the recurrence relation\n$$ \\mathrm{He}_{n+1}(x) = x \\mathrm{He}_{n}(x) - n \\mathrm{He}_{n-1}(x) $$for $n \\geq 2$ with $\\mathrm{He}_0(x) = 1$ and $\\mathrm{He}_1(x) = x$.\nThe Hermite polynomials are orthogonal with respect to the (normalized) weight function $w(x) = \\exp(-x^2/2)/\\sqrt{2\\pi}$ on the interval $(-\\infty, \\infty)$. The $\\mathrm{L}^2$ norm of $\\mathrm{He}_n(x)$ with respect to this weight function is given by\n$$ ||\\mathrm{He}_n||_{\\mathrm{L}^2} = \\sqrt{n!} $$ for $n \\geq 0$. Letâ€™s denote the normalized Hermite polynomials by\n$$ \\mathrm{H}_n = \\frac{\\mathrm{He}_n}{||\\mathrm{He}_n||_{\\mathrm{L}^2}} = \\frac{\\mathrm{He}_n}{\\sqrt{n!}}. $$It is well-known that the eigenvalues of the Hermite generating matrix $\\mathrm{T}_n$ of size $n$ are given by the roots of the Hermite polynomial $\\mathrm{H}_n(x)$, and the eigenvectors are given by the values of the Hermite polynomials at the roots, namely\n$$ \\mathrm{T}_n \\mathbf{v}_{n,k} = \\lambda_{n,k} \\mathbf{v}_{n,k} $$ where $\\lambda_{n,k}$ is the $k$-th root of $\\mathrm{He}_n(x)$, and\n$$ \\mathbf{v}_{n,k} = \\begin{pmatrix} \\mathrm{H}_0(\\lambda_{n,k}) \\\\ \\mathrm{H}_1(\\lambda_{n,k}) \\\\ \\cdots \\\\ \\mathrm{H}_{n-1}(\\lambda_{n,k}) \\end{pmatrix} $$ is the corresponding eigenvector.\nTo see this, we do a direct computation\n$$ \\mathrm{T}_n \\mathbf{v}_{n,k} = \\begin{pmatrix} \\sqrt{1} \\mathrm{H}_1(\\lambda_{n,k}) \\\\ \\sqrt{1} \\mathrm{H}_0(\\lambda_{n,k}) + \\sqrt{2} \\mathrm{H}_2(\\lambda_{n,k}) \\\\ \\cdots\\\\ \\sqrt{n-2} \\mathrm{H}_{n-3}(\\lambda_{n,k}) + \\sqrt{n-1} \\mathrm{H}_{n-1}(\\lambda_{n,k}) \\\\ \\sqrt{n-1} \\mathrm{H}_{n-2}(\\lambda_{n,k}) + \\sqrt{n} \\underbrace{\\mathrm{H}_{n}(\\lambda_{n,k})}_{=0} \\end{pmatrix} = \\begin{pmatrix} \\lambda_{n,k} \\mathrm{H}_0(\\lambda_{n,k}) \\\\ \\lambda_{n,k} \\mathrm{H}_1(\\lambda_{n,k}) \\\\ \\cdots \\\\ \\lambda_{n,k} \\mathrm{H}_{n-1}(\\lambda_{n,k}) \\end{pmatrix} = \\lambda_{n,k} \\mathbf{v}_{n,k}. $$Letâ€™s define $\\mathbf{w}_{n,k} = {\\mathbf{v}_{n,k}}/{||\\mathbf{v}_{n,k}||_2}$, which is the normalized eigenvector, and\n$$ \\mathrm{P}_n := \\begin{pmatrix} \\mathbf{w}_{n,1} \u0026 \\mathbf{w}_{n,2} \u0026 \\cdots \u0026 \\mathbf{w}_{n,n} \\end{pmatrix} $$is the change of basis matrix. It follows that\n$$ \\mathrm{P}_n^T \\mathrm{T}_n \\mathrm{P}_n = \\mathrm{D}_n:= \\mathrm{diag}(\\lambda_{n,1}, \\lambda_{n,1}, \\cdots, \\lambda_{n,n}). $$Thus, in theory, we can compute the eigenvalues and eigenvectors of the Hermite generating matrix $\\mathrm{T}_n$ by computing the roots of the normalized Hermite polynomial $\\mathrm{H}_n(x)$ and evaluating the normalized Hermite polynomials at these roots.\nNumerical properties of the Hermite polynomials Numerical instability when evaluating the Hermite polynomials The first thing we need to note is that the Hermite polynomialsâ€™ coefficients grow very quickly as $n$ increases. Very large and very small coefficients exist in the polynomial, which can lead to numerical instability when evaluating the polynomial. For example,\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 using Polynomials function He_symbolic(n::Int) He_0 = Polynomial([1.0]) if n == 0 return He_0 end He_1 = Polynomial([0.0, 1.0]) if n == 1 return He_1 end for k in 2:n He_2 = Polynomial([0.0, 1.0]) * He_1 - (k - 1) * He_0 He_0, He_1 = He_1, He_2 end return He_1 end 1 He_symbolic(15) -2.027025e6âˆ™x + 4.729725e6âˆ™x3 - 2.837835e6âˆ™x5 + 675675.0âˆ™x7 - 75075.0âˆ™x9 + 4095.0âˆ™x11 - 105.0âˆ™x13 + 1.0âˆ™x15\nFor $n=20$, the largest coefficient is around $10^{6}$, while the smallest is always $1.0$, this could lead to numerical instability when evaluating the polynomial directly. To solve this problem, we can use the recurrence relation to evaluate the polynomial, which should give us a more stable result for small $n$.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 function He(n::Int, x::Float64) He_0 = 1.0 if n == 0 return He_0 end He_1 = x for k in 2:n He_2 = x * He_1 - (k - 1) * He_0 He_0, He_1 = He_1, He_2 end return He_1 end 1 2 3 4 5 6 x = 1.1 n = 51 val_direct = He_symbolic(n)(x) val_recursive = He(n, x) val_direct, val_recursive (-5.624972601518976e32, -5.624972601518795e32) We can see relatively small but noticeable discrepancies between the two methods, since Polynomials.jl already uses numerically stable methods to evaluate a polynomial. For our purposes, we use the recursive evaluation.\nNumerical instability when computing the roots of the Hermite polynomials The second thing we need to note is that the roots of the Hermite polynomials are very close to each other, especially for large $n$. This can lead to numerical instability when computing the roots of the polynomial. For example, for $n=15$, the roots are\n1 println(sort(roots(He_symbolic(15)))) [-6.36394788882981, -5.190093591304892, -4.196207711268877, -3.2890824243988406, -2.4324368270097385, -1.6067100690287315, -0.7991290683245481, 0.0, 0.7991290683245479, 1.6067100690287317, 2.4324368270097474, 3.2890824243988055, 4.196207711268944, 5.190093591304826, 6.36394788882981] As we can see, roots are clustered around $x=0$, and does not become more spaced out as $n$ increases. To see this, we can plot the roots of the Hermite polynomials for $n=1, \\dots, 20$.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 using Plots # Collect roots for n=1:20 root_data = [] for n in 1:20 push!(root_data, roots(He_symbolic(n))) end # Flatten the root data and associate each root with its corresponding n x_vals = vcat(root_data...) y_vals = vcat([fill(n, length(root_data[n])) for n in 1:20]...) # Plot the roots distribution scatter(x_vals, y_vals, xlabel=\"Roots\", ylabel=\"n\", title=\"Roots Distribution of Hermite polynomials for n=1:20\", legend=false) To efficiently compute the roots of the Hermite polynomials, we can use the generating matrix $\\mathrm{T}_n$ and compute the eigenvalues of the matrix. This is a numerically stable method as the matrix is tridiagonal, symmetric, and there exists numerically stable algorithms to compute the eigenvalues and eigenvectors of such matrices.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 function T(n::Int) d = zeros(n) e = sqrt.(1:n-1) T = SymTridiagonal(d, e) return T end using LinearAlgebra function get_eigen(n::Int) Tn = T(n) F = eigen(Tn) # Eigenvalues and eigenvectors idx = sortperm(F.values) # Sort eigenvalues and eigenvectors eigenvals = F.values[idx] # Sorted eigenvalues (roots) eigenvecs = F.vectors[:, idx] # Sorted eigenvectors # One step of Newton's method to refine the roots He_nx = He.(n, eigenvals) # Hermite polynomial at the roots He_nm1x = He.(n-1, eigenvals) # Candidate for the derivative eigenvals .-= He_nx ./ (n .* He_nm1x) return eigenvals, eigenvecs end get_eigen (generic function with 1 method) 1 2 3 eigenvals, _ = get_eigen(5) println(\"Eigenvalues for n=5: \", eigenvals) println(sort(roots(He_symbolic(5)))) Eigenvalues for n=5: [-2.8569700138728056, -1.355626179974266, 0.0, 1.355626179974266, 2.8569700138728056] [-2.856970013872804, -1.3556261799742675, 0.0, 1.3556261799742657, 2.856970013872808] From the above comparison, we can see that the eigenvalues computed from the generating matrix preserve the symmetry of the roots better. As $n$ increases, this algorithm becomes more efficient than the root-finding algorithm, as the roots become more clustered together.\nNormalized eigenvectors of the Hermite generating matrix Now we are in a position to compute the eigenvectors of the Hermite generating matrix $\\mathrm{T}_n$. Note that we already computed the eigenvalues and eigenvectors of the Hermite generating matrix $\\mathrm{T}_n$ in the previous section using a numerically robust method. In this section, we will construct the normalized eigenvectors of the Hermite generating matrix by evaluating the normalized Hermite polynomials at the roots of the Hermite polynomial, i.e. $\\mathbf{v}_{n,k}$ for $k=1, \\dots, n$.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 using SpecialFunctions: logfactorial # An auxiliary function to compute the normalization constant function He_norm(n::Int) return sqrt(exp(logfactorial(n))) end function analytic_eigenvecs(n::Int) Pmat = zeros(Float64, n, n) # initializing the matrix rts, _ = get_eigen(n) # Get the roots for i in 1:n root_i = rts[i] for j in 1:n Pmat[j, i] = He(j-1, root_i) / He_norm(j-1) end # Normalize each vector (column) Pmat[:, i] /= norm(Pmat[:, i]) end return Pmat end Numerical properties of the eigenvectors Now, we have two ways to compute the eigenvectors of the Hermite generating matrix $\\mathrm{T}_n$: one is theoretically precise, the other is numerical. We will compare the two methods and see how well they agree with each other.\nThere are two important properties of the eigenvectors of the Hermite generating matrix $\\mathrm{T}_n$ that we need to note:\nThe column matrix $\\mathrm{P}_n$ of eigenvectors is orthonormal, i.e. $\\mathrm{P}_n^T \\mathrm{P}_n = \\mathrm{I}_n$. By conjugating the eigenvectors, we can obtain the eigenvalues of the Hermite generating matrix $\\mathrm{T}_n$, which is a diagonal matrix $\\mathrm{D}_n$ with the roots of the Hermite polynomial on the diagonal. $$ \\mathrm{P}_n^T \\mathrm{T}_n \\mathrm{P}_n = \\mathrm{D}_n. $$ We will check how well these properties hold for both methods of computing the eigenvectors. The following codes compute the $\\infty$ norm of the above two properties.\n1 2 3 4 5 6 7 function orthonormality_error(P::Matrix{Float64}) return norm(P' * P - I, Inf) end function diagonal_error(P::Matrix{Float64}, eigenvals::Vector{Float64}, n::Int) return norm(P' * T(n) * P - Diagonal(eigenvals), Inf) end 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 # Define the range of n n_values = 2:200 # Initialize error arrays for both methods analytic_orth_errors = Float64[] analytic_diag_errors = Float64[] numerical_orth_errors = Float64[] numerical_diag_errors = Float64[] # Compute errors for both methods for n in n_values P_analytic = analytic_eigenvecs(n) rts, P_numerical = get_eigen(n) push!(analytic_orth_errors, orthonormality_error(P_analytic)) push!(analytic_diag_errors, diagonal_error(P_analytic, rts, n)) push!(numerical_orth_errors, orthonormality_error(P_numerical)) push!(numerical_diag_errors, diagonal_error(P_numerical, rts, n)) end # Create 2x2 subplots p1 = plot(n_values, log10.(analytic_orth_errors), label=\"Analytic\", title=\"Log-scale Orthonormality Error\", xlabel=\"n\", ylabel=\"Error\") plot!(p1, n_values, log10.(numerical_orth_errors), label=\"Numerical\") p2 = plot(n_values, log10.(analytic_diag_errors), label=\"Analytic\", title=\"Log-scale Diagonalization Error\", xlabel=\"n\", ylabel=\"Error\") plot!(p2, n_values, log10.(numerical_diag_errors), label=\"Numerical\") plot(p1, p2, layout=(2, 1)) From the plot we can see that the analytical method is marginally better than the numerical method before $n\\approx 170$, but both errors for analytical method blow up after $n\\approx 170$, while the numerical method remains stable. The reason for this is that in the analytical method, we need to compute the normalization factor of the Hermite polynomial, which is given by $||\\mathrm{He}_n||_{\\mathrm{L}^2} = \\sqrt{n!}$, and the factorial grows very quickly, eventually blows up at $n\\approx 170$.\n1 2 3 for n in 169:172 print(He_norm(n), \", \") end 2.0661723086434517e152, 2.6939590968143674e153, Inf, Inf, This suggests that we can use the analytical method for small $n$, such as $n\u003c50$, where the analytical method diagnoalizes the matrix $\\mathrm{T}_n$ more accurately than the numerical method. In practice, using large $n$ for the Hermite polynomials is not recommended, as there are already numerical instabilities when evaluating the Hermite polynomials.\n",
  "wordCount" : "1803",
  "inLanguage": "en",
  "datePublished": "2025-05-02T00:00:00Z",
  "dateModified": "2025-05-02T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "Mingyi Hou"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "http://localhost:1313/posts/25-05-02_hermite-numerics/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Mingyi's Page",
    "logo": {
      "@type": "ImageObject",
      "url": "http://localhost:1313/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/" accesskey="h" title="Mingyi&#39;s Page (Alt + H)">Mingyi&#39;s Page</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://localhost:1313/posts/" title="Posts">
                    <span>Posts</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/projects/" title="Projects">
                    <span>Projects</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="http://localhost:1313/">Home</a>&nbsp;Â»&nbsp;<a href="http://localhost:1313/posts/">Posts</a></div>
    <h1 class="post-title entry-hint-parent">
      Numerical Methods for Hermite Polynomials
    </h1>
    <div class="post-meta"><span title='2025-05-02 00:00:00 +0000 UTC'>May 2, 2025</span>&nbsp;Â·&nbsp;9 min&nbsp;Â·&nbsp;Mingyi Hou

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#theoretical-eigenvalues-and-eigenvectors" aria-label="Theoretical eigenvalues and eigenvectors">Theoretical eigenvalues and eigenvectors</a></li>
                <li>
                    <a href="#numerical-properties-of-the-hermite-polynomials" aria-label="Numerical properties of the Hermite polynomials">Numerical properties of the Hermite polynomials</a><ul>
                        
                <li>
                    <a href="#numerical-instability-when-evaluating-the-hermite-polynomials" aria-label="Numerical instability when evaluating the Hermite polynomials">Numerical instability when evaluating the Hermite polynomials</a></li>
                <li>
                    <a href="#numerical-instability-when-computing-the-roots-of-the-hermite-polynomials" aria-label="Numerical instability when computing the roots of the Hermite polynomials">Numerical instability when computing the roots of the Hermite polynomials</a></li></ul>
                </li>
                <li>
                    <a href="#normalized-eigenvectors-of-the-hermite-generating-matrix" aria-label="Normalized eigenvectors of the Hermite generating matrix">Normalized eigenvectors of the Hermite generating matrix</a><ul>
                        
                <li>
                    <a href="#numerical-properties-of-the-eigenvectors" aria-label="Numerical properties of the eigenvectors">Numerical properties of the eigenvectors</a>
                </li>
            </ul>
            </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><p>In this post, we will explore the numerics of Hermite polynomials, as part of a numerical solver project for Kramers hyperbolic system. In particular, we try to compute eigenvectors numerically for the Hermite generating matrix, which is a tridiagonal matrix given by the recurrence relation</p>
$$
x \mathrm{H}_{n}(x) = \sqrt{n+1} \mathrm{H}_{n+1}(x) - \sqrt{n} \mathrm{H}_{n-1}(x)
$$<p>for \( n \geq 1 \) with \(\mathrm{H}_{n}(x)\) being the \(n\)-th normalized Hermite polynomial.
The generating matrix is given by</p>
$$
\mathrm{T}_n = 
\begin{pmatrix}
0 & \sqrt{1} & 0 & \cdots & \cdots \\
\sqrt{1} & 0 & \sqrt{2} & \cdots & \cdots \\
0 & \sqrt{2} & \ddots & \cdots & \cdots \\
\vdots & \vdots & \vdots & 0 & \sqrt{n-1} \\
\vdots & \vdots & \vdots & \sqrt{n-1} & 0
\end{pmatrix}.
$$<p><em>All the codes below are implemented in Julia</em>.</p>
<h2 id="theoretical-eigenvalues-and-eigenvectors">Theoretical eigenvalues and eigenvectors<a hidden class="anchor" aria-hidden="true" href="#theoretical-eigenvalues-and-eigenvectors">#</a></h2>
<p>Recall that the Hermite polynomials are defined by</p>
$$
\mathrm{He}_n(x) = (-1)^n \exp(x^2/2) \frac{\mathrm{d}^n}{\mathrm{d}x^n} \left( \exp(-x^2/2) \right)
$$<p>for $n \geq 0$.
The first few Hermite polynomials are given by</p>
$$
\mathrm{He}_0(x) = 1, 
\\
\mathrm{He}_1(x) = x, 
\\
\mathrm{He}_2(x) = x^2 - 1,
\\
\mathrm{He}_3(x) = x^3 - 3x.
$$<p>The Hermite polynomials can be computed using the recurrence relation</p>
$$
\mathrm{He}_{n+1}(x) = x \mathrm{He}_{n}(x) - n \mathrm{He}_{n-1}(x)
$$<p>for $n \geq 2$ with $\mathrm{He}_0(x) = 1$ and $\mathrm{He}_1(x) = x$.</p>
<p>The Hermite polynomials are orthogonal with respect to the (normalized) weight function $w(x) = \exp(-x^2/2)/\sqrt{2\pi}$ on the interval $(-\infty, \infty)$.
The $\mathrm{L}^2$ norm of $\mathrm{He}_n(x)$ with respect to this weight function is given by</p>
$$
||\mathrm{He}_n||_{\mathrm{L}^2} = \sqrt{n!}
$$<p>
for $n \geq 0$.
Let&rsquo;s denote the normalized Hermite polynomials by</p>
$$
\mathrm{H}_n = \frac{\mathrm{He}_n}{||\mathrm{He}_n||_{\mathrm{L}^2}} = \frac{\mathrm{He}_n}{\sqrt{n!}}.
$$<p>It is well-known that the eigenvalues of the Hermite generating matrix $\mathrm{T}_n$ of size $n$ are given by the roots of the Hermite polynomial $\mathrm{H}_n(x)$, and the eigenvectors are given by the values of the Hermite polynomials at the roots, namely</p>
$$
\mathrm{T}_n \mathbf{v}_{n,k} = \lambda_{n,k} \mathbf{v}_{n,k}
$$<p>
where $\lambda_{n,k}$ is the $k$-th root of $\mathrm{He}_n(x)$, and</p>
$$
\mathbf{v}_{n,k} = \begin{pmatrix} \mathrm{H}_0(\lambda_{n,k}) \\ \mathrm{H}_1(\lambda_{n,k}) \\ \cdots \\ \mathrm{H}_{n-1}(\lambda_{n,k}) \end{pmatrix}
$$<p>
is the corresponding eigenvector.</p>
<p>To see this, we do a direct computation</p>
$$
\mathrm{T}_n \mathbf{v}_{n,k} = \begin{pmatrix}
\sqrt{1} \mathrm{H}_1(\lambda_{n,k}) \\ \sqrt{1} \mathrm{H}_0(\lambda_{n,k}) + \sqrt{2} \mathrm{H}_2(\lambda_{n,k}) \\ \cdots\\ \sqrt{n-2} \mathrm{H}_{n-3}(\lambda_{n,k}) + \sqrt{n-1} \mathrm{H}_{n-1}(\lambda_{n,k}) \\ \sqrt{n-1} \mathrm{H}_{n-2}(\lambda_{n,k}) + \sqrt{n} \underbrace{\mathrm{H}_{n}(\lambda_{n,k})}_{=0}
\end{pmatrix}
= \begin{pmatrix}
\lambda_{n,k} \mathrm{H}_0(\lambda_{n,k}) \\ \lambda_{n,k} \mathrm{H}_1(\lambda_{n,k}) \\ \cdots \\ \lambda_{n,k} \mathrm{H}_{n-1}(\lambda_{n,k})
\end{pmatrix}
= \lambda_{n,k} \mathbf{v}_{n,k}.
$$<p>Let&rsquo;s define $\mathbf{w}_{n,k} = {\mathbf{v}_{n,k}}/{||\mathbf{v}_{n,k}||_2}$, which is the normalized eigenvector, and</p>
$$
\mathrm{P}_n := \begin{pmatrix}
\mathbf{w}_{n,1} & \mathbf{w}_{n,2} & \cdots & \mathbf{w}_{n,n}
\end{pmatrix}
$$<p>is the change of basis matrix.
It follows that</p>
$$
\mathrm{P}_n^T \mathrm{T}_n \mathrm{P}_n = \mathrm{D}_n:= \mathrm{diag}(\lambda_{n,1}, \lambda_{n,1}, \cdots, \lambda_{n,n}).
$$<p>Thus, in theory, we can compute the eigenvalues and eigenvectors of the Hermite generating matrix $\mathrm{T}_n$ by computing the roots of the normalized Hermite polynomial $\mathrm{H}_n(x)$ and evaluating the normalized Hermite polynomials at these roots.</p>
<h2 id="numerical-properties-of-the-hermite-polynomials">Numerical properties of the Hermite polynomials<a hidden class="anchor" aria-hidden="true" href="#numerical-properties-of-the-hermite-polynomials">#</a></h2>
<h3 id="numerical-instability-when-evaluating-the-hermite-polynomials">Numerical instability when evaluating the Hermite polynomials<a hidden class="anchor" aria-hidden="true" href="#numerical-instability-when-evaluating-the-hermite-polynomials">#</a></h3>
<p>The first thing we need to note is that the Hermite polynomials&rsquo; coefficients grow very quickly as $n$ increases. Very large and very small coefficients exist in the polynomial, which can lead to numerical instability when evaluating the polynomial.
For example,</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-julia" data-lang="julia"><span class="line"><span class="cl"><span class="k">using</span> <span class="n">Polynomials</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">function</span> <span class="n">He_symbolic</span><span class="p">(</span><span class="n">n</span><span class="o">::</span><span class="kt">Int</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">He_0</span> <span class="o">=</span> <span class="n">Polynomial</span><span class="p">([</span><span class="mf">1.0</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">He_0</span>
</span></span><span class="line"><span class="cl">    <span class="k">end</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">He_1</span> <span class="o">=</span> <span class="n">Polynomial</span><span class="p">([</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">He_1</span>
</span></span><span class="line"><span class="cl">    <span class="k">end</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">k</span> <span class="k">in</span> <span class="mi">2</span><span class="o">:</span><span class="n">n</span>
</span></span><span class="line"><span class="cl">        <span class="n">He_2</span> <span class="o">=</span> <span class="n">Polynomial</span><span class="p">([</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">])</span> <span class="o">*</span> <span class="n">He_1</span> <span class="o">-</span> <span class="p">(</span><span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">He_0</span>
</span></span><span class="line"><span class="cl">        <span class="n">He_0</span><span class="p">,</span> <span class="n">He_1</span> <span class="o">=</span> <span class="n">He_1</span><span class="p">,</span> <span class="n">He_2</span>
</span></span><span class="line"><span class="cl">    <span class="k">end</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">He_1</span>
</span></span><span class="line"><span class="cl"><span class="k">end</span>
</span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-julia" data-lang="julia"><span class="line"><span class="cl"><span class="n">He_symbolic</span><span class="p">(</span><span class="mi">15</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>-2.027025e6âˆ™x + 4.729725e6âˆ™x<sup>3</sup> - 2.837835e6âˆ™x<sup>5</sup> + 675675.0âˆ™x<sup>7</sup> - 75075.0âˆ™x<sup>9</sup> + 4095.0âˆ™x<sup>11</sup> - 105.0âˆ™x<sup>13</sup> + 1.0âˆ™x<sup>15</sup></p>
<p>For $n=20$, the largest coefficient is around $10^{6}$, while the smallest is always $1.0$, this could lead to numerical instability when evaluating the polynomial directly.
To solve this problem, we can use the recurrence relation to evaluate the polynomial, which should give us a more stable result for small $n$.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-julia" data-lang="julia"><span class="line"><span class="cl"><span class="k">function</span> <span class="n">He</span><span class="p">(</span><span class="n">n</span><span class="o">::</span><span class="kt">Int</span><span class="p">,</span> <span class="n">x</span><span class="o">::</span><span class="kt">Float64</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">He_0</span> <span class="o">=</span> <span class="mf">1.0</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">He_0</span>
</span></span><span class="line"><span class="cl">    <span class="k">end</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">He_1</span> <span class="o">=</span> <span class="n">x</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">k</span> <span class="k">in</span> <span class="mi">2</span><span class="o">:</span><span class="n">n</span>
</span></span><span class="line"><span class="cl">        <span class="n">He_2</span> <span class="o">=</span> <span class="n">x</span> <span class="o">*</span> <span class="n">He_1</span> <span class="o">-</span> <span class="p">(</span><span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">He_0</span>
</span></span><span class="line"><span class="cl">        <span class="n">He_0</span><span class="p">,</span> <span class="n">He_1</span> <span class="o">=</span> <span class="n">He_1</span><span class="p">,</span> <span class="n">He_2</span>
</span></span><span class="line"><span class="cl">    <span class="k">end</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">He_1</span>
</span></span><span class="line"><span class="cl"><span class="k">end</span>
</span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-julia" data-lang="julia"><span class="line"><span class="cl"><span class="n">x</span> <span class="o">=</span> <span class="mf">1.1</span>
</span></span><span class="line"><span class="cl"><span class="n">n</span> <span class="o">=</span> <span class="mi">51</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">val_direct</span> <span class="o">=</span> <span class="n">He_symbolic</span><span class="p">(</span><span class="n">n</span><span class="p">)(</span><span class="n">x</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">val_recursive</span> <span class="o">=</span> <span class="n">He</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">val_direct</span><span class="p">,</span> <span class="n">val_recursive</span>
</span></span></code></pre></td></tr></table>
</div>
</div><pre><code>(-5.624972601518976e32, -5.624972601518795e32)
</code></pre>
<p>We can see relatively small but noticeable discrepancies between the two methods, since <code>Polynomials.jl</code> already uses numerically stable methods to evaluate a polynomial. For our purposes, we use the recursive evaluation.</p>
<h3 id="numerical-instability-when-computing-the-roots-of-the-hermite-polynomials">Numerical instability when computing the roots of the Hermite polynomials<a hidden class="anchor" aria-hidden="true" href="#numerical-instability-when-computing-the-roots-of-the-hermite-polynomials">#</a></h3>
<p>The second thing we need to note is that the roots of the Hermite polynomials are very close to each other, especially for large $n$. This can lead to numerical instability when computing the roots of the polynomial.
For example, for $n=15$, the roots are</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-julia" data-lang="julia"><span class="line"><span class="cl"><span class="n">println</span><span class="p">(</span><span class="n">sort</span><span class="p">(</span><span class="n">roots</span><span class="p">(</span><span class="n">He_symbolic</span><span class="p">(</span><span class="mi">15</span><span class="p">))))</span>
</span></span></code></pre></td></tr></table>
</div>
</div><pre><code>[-6.36394788882981, -5.190093591304892, -4.196207711268877, -3.2890824243988406, -2.4324368270097385, -1.6067100690287315, -0.7991290683245481, 0.0, 0.7991290683245479, 1.6067100690287317, 2.4324368270097474, 3.2890824243988055, 4.196207711268944, 5.190093591304826, 6.36394788882981]
</code></pre>
<p>As we can see, roots are clustered around $x=0$, and does not become more spaced out as $n$ increases. To see this, we can plot the roots of the Hermite polynomials for $n=1, \dots, 20$.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-julia" data-lang="julia"><span class="line"><span class="cl"><span class="k">using</span> <span class="n">Plots</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c"># Collect roots for n=1:20</span>
</span></span><span class="line"><span class="cl"><span class="n">root_data</span> <span class="o">=</span> <span class="p">[]</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="n">n</span> <span class="k">in</span> <span class="mi">1</span><span class="o">:</span><span class="mi">20</span>
</span></span><span class="line"><span class="cl">    <span class="n">push!</span><span class="p">(</span><span class="n">root_data</span><span class="p">,</span> <span class="n">roots</span><span class="p">(</span><span class="n">He_symbolic</span><span class="p">(</span><span class="n">n</span><span class="p">)))</span>
</span></span><span class="line"><span class="cl"><span class="k">end</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c"># Flatten the root data and associate each root with its corresponding n</span>
</span></span><span class="line"><span class="cl"><span class="n">x_vals</span> <span class="o">=</span> <span class="n">vcat</span><span class="p">(</span><span class="n">root_data</span><span class="o">...</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">y_vals</span> <span class="o">=</span> <span class="n">vcat</span><span class="p">([</span><span class="n">fill</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">length</span><span class="p">(</span><span class="n">root_data</span><span class="p">[</span><span class="n">n</span><span class="p">]))</span> <span class="k">for</span> <span class="n">n</span> <span class="k">in</span> <span class="mi">1</span><span class="o">:</span><span class="mi">20</span><span class="p">]</span><span class="o">...</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c"># Plot the roots distribution</span>
</span></span><span class="line"><span class="cl"><span class="n">scatter</span><span class="p">(</span><span class="n">x_vals</span><span class="p">,</span> <span class="n">y_vals</span><span class="p">,</span> <span class="n">xlabel</span><span class="o">=</span><span class="s">&#34;Roots&#34;</span><span class="p">,</span> <span class="n">ylabel</span><span class="o">=</span><span class="s">&#34;n&#34;</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s">&#34;Roots Distribution of Hermite polynomials for n=1:20&#34;</span><span class="p">,</span> <span class="n">legend</span><span class="o">=</span><span class="nb">false</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><img alt="Roots Distribution of Hermite polynomials for n=1:20" loading="lazy" src="/images/25-05-02_Hermite-numerics/JL-Hermite_9_0.png"></p>
<p>To efficiently compute the roots of the Hermite polynomials, we can use the generating matrix $\mathrm{T}_n$ and compute the eigenvalues of the matrix. This is a numerically stable method as the matrix is tridiagonal, symmetric, and there exists numerically stable algorithms to compute the eigenvalues and eigenvectors of such matrices.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-julia" data-lang="julia"><span class="line"><span class="cl"><span class="k">function</span> <span class="n">T</span><span class="p">(</span><span class="n">n</span><span class="o">::</span><span class="kt">Int</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">d</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">e</span> <span class="o">=</span> <span class="n">sqrt</span><span class="o">.</span><span class="p">(</span><span class="mi">1</span><span class="o">:</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">T</span> <span class="o">=</span> <span class="n">SymTridiagonal</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">T</span>
</span></span><span class="line"><span class="cl"><span class="k">end</span>
</span></span><span class="line"><span class="cl">   
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="n">LinearAlgebra</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">function</span> <span class="n">get_eigen</span><span class="p">(</span><span class="n">n</span><span class="o">::</span><span class="kt">Int</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">Tn</span> <span class="o">=</span> <span class="n">T</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">F</span> <span class="o">=</span> <span class="n">eigen</span><span class="p">(</span><span class="n">Tn</span><span class="p">)</span>                      <span class="c"># Eigenvalues and eigenvectors</span>
</span></span><span class="line"><span class="cl">    <span class="n">idx</span> <span class="o">=</span> <span class="n">sortperm</span><span class="p">(</span><span class="n">F</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>           <span class="c"># Sort eigenvalues and eigenvectors</span>
</span></span><span class="line"><span class="cl">    <span class="n">eigenvals</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>          <span class="c"># Sorted eigenvalues (roots)</span>
</span></span><span class="line"><span class="cl">    <span class="n">eigenvecs</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">vectors</span><span class="p">[</span><span class="o">:</span><span class="p">,</span> <span class="n">idx</span><span class="p">]</span>      <span class="c"># Sorted eigenvectors</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c"># One step of Newton&#39;s method to refine the roots</span>
</span></span><span class="line"><span class="cl">    <span class="n">He_nx</span> <span class="o">=</span> <span class="n">He</span><span class="o">.</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">eigenvals</span><span class="p">)</span>          <span class="c"># Hermite polynomial at the roots</span>
</span></span><span class="line"><span class="cl">    <span class="n">He_nm1x</span> <span class="o">=</span> <span class="n">He</span><span class="o">.</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">eigenvals</span><span class="p">)</span>      <span class="c"># Candidate for the derivative</span>
</span></span><span class="line"><span class="cl">    <span class="n">eigenvals</span> <span class="o">.-=</span> <span class="n">He_nx</span> <span class="o">./</span> <span class="p">(</span><span class="n">n</span> <span class="o">.*</span> <span class="n">He_nm1x</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">eigenvals</span><span class="p">,</span> <span class="n">eigenvecs</span>
</span></span><span class="line"><span class="cl"><span class="k">end</span>
</span></span></code></pre></td></tr></table>
</div>
</div><pre><code>get_eigen (generic function with 1 method)
</code></pre>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-julia" data-lang="julia"><span class="line"><span class="cl"><span class="n">eigenvals</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">get_eigen</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">println</span><span class="p">(</span><span class="s">&#34;Eigenvalues for n=5: &#34;</span><span class="p">,</span> <span class="n">eigenvals</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">println</span><span class="p">(</span><span class="n">sort</span><span class="p">(</span><span class="n">roots</span><span class="p">(</span><span class="n">He_symbolic</span><span class="p">(</span><span class="mi">5</span><span class="p">))))</span>
</span></span></code></pre></td></tr></table>
</div>
</div><pre><code>Eigenvalues for n=5: [-2.8569700138728056, -1.355626179974266, 0.0, 1.355626179974266, 2.8569700138728056]
[-2.856970013872804, -1.3556261799742675, 0.0, 1.3556261799742657, 2.856970013872808]
</code></pre>
<p>From the above comparison, we can see that the eigenvalues computed from the generating matrix preserve the symmetry of the roots better. As $n$ increases, this algorithm becomes more efficient than the root-finding algorithm, as the roots become more clustered together.</p>
<h2 id="normalized-eigenvectors-of-the-hermite-generating-matrix">Normalized eigenvectors of the Hermite generating matrix<a hidden class="anchor" aria-hidden="true" href="#normalized-eigenvectors-of-the-hermite-generating-matrix">#</a></h2>
<p>Now we are in a position to compute the eigenvectors of the Hermite generating matrix $\mathrm{T}_n$.
Note that we already computed the eigenvalues and eigenvectors of the Hermite generating matrix $\mathrm{T}_n$ in the previous section using a numerically robust method.
In this section, we will construct the normalized eigenvectors of the Hermite generating matrix by evaluating the normalized Hermite polynomials at the roots of the Hermite polynomial, i.e. $\mathbf{v}_{n,k}$ for $k=1, \dots, n$.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-julia" data-lang="julia"><span class="line"><span class="cl"><span class="k">using</span> <span class="n">SpecialFunctions</span><span class="o">:</span> <span class="n">logfactorial</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c"># An auxiliary function to compute the normalization constant</span>
</span></span><span class="line"><span class="cl"><span class="k">function</span> <span class="n">He_norm</span><span class="p">(</span><span class="n">n</span><span class="o">::</span><span class="kt">Int</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">exp</span><span class="p">(</span><span class="n">logfactorial</span><span class="p">(</span><span class="n">n</span><span class="p">)))</span>
</span></span><span class="line"><span class="cl"><span class="k">end</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">function</span> <span class="n">analytic_eigenvecs</span><span class="p">(</span><span class="n">n</span><span class="o">::</span><span class="kt">Int</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">Pmat</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="kt">Float64</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span> <span class="c"># initializing the matrix</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">rts</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">get_eigen</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>  <span class="c"># Get the roots</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">1</span><span class="o">:</span><span class="n">n</span>
</span></span><span class="line"><span class="cl">        <span class="n">root_i</span> <span class="o">=</span> <span class="n">rts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="n">j</span> <span class="k">in</span> <span class="mi">1</span><span class="o">:</span><span class="n">n</span>
</span></span><span class="line"><span class="cl">            <span class="n">Pmat</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">He</span><span class="p">(</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">root_i</span><span class="p">)</span> <span class="o">/</span> <span class="n">He_norm</span><span class="p">(</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">end</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c"># Normalize each vector (column)</span>
</span></span><span class="line"><span class="cl">        <span class="n">Pmat</span><span class="p">[</span><span class="o">:</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">/=</span> <span class="n">norm</span><span class="p">(</span><span class="n">Pmat</span><span class="p">[</span><span class="o">:</span><span class="p">,</span> <span class="n">i</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">    <span class="k">end</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">Pmat</span>
</span></span><span class="line"><span class="cl"><span class="k">end</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="numerical-properties-of-the-eigenvectors">Numerical properties of the eigenvectors<a hidden class="anchor" aria-hidden="true" href="#numerical-properties-of-the-eigenvectors">#</a></h3>
<p>Now, we have two ways to compute the eigenvectors of the Hermite generating matrix $\mathrm{T}_n$: one is theoretically precise, the other is numerical. We will compare the two methods and see how well they agree with each other.</p>
<p>There are two important properties of the eigenvectors of the Hermite generating matrix $\mathrm{T}_n$ that we need to note:</p>
<ol>
<li>The column matrix $\mathrm{P}_n$ of eigenvectors is orthonormal, i.e. $\mathrm{P}_n^T \mathrm{P}_n = \mathrm{I}_n$.</li>
<li>By conjugating the eigenvectors, we can obtain the eigenvalues of the Hermite generating matrix $\mathrm{T}_n$, which is a diagonal matrix $\mathrm{D}_n$ with the roots of the Hermite polynomial on the diagonal.
$$
\mathrm{P}_n^T \mathrm{T}_n \mathrm{P}_n = \mathrm{D}_n.
$$</li>
</ol>
<p>We will check how well these properties hold for both methods of computing the eigenvectors. The following codes compute the $\infty$ norm of the above two properties.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-julia" data-lang="julia"><span class="line"><span class="cl"><span class="k">function</span> <span class="n">orthonormality_error</span><span class="p">(</span><span class="n">P</span><span class="o">::</span><span class="kt">Matrix</span><span class="p">{</span><span class="kt">Float64</span><span class="p">})</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">norm</span><span class="p">(</span><span class="n">P</span><span class="o">&#39;</span> <span class="o">*</span> <span class="n">P</span> <span class="o">-</span> <span class="n">I</span><span class="p">,</span> <span class="nb">Inf</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="k">end</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">function</span> <span class="n">diagonal_error</span><span class="p">(</span><span class="n">P</span><span class="o">::</span><span class="kt">Matrix</span><span class="p">{</span><span class="kt">Float64</span><span class="p">},</span> <span class="n">eigenvals</span><span class="o">::</span><span class="kt">Vector</span><span class="p">{</span><span class="kt">Float64</span><span class="p">},</span> <span class="n">n</span><span class="o">::</span><span class="kt">Int</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">norm</span><span class="p">(</span><span class="n">P</span><span class="o">&#39;</span> <span class="o">*</span> <span class="n">T</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">*</span>  <span class="n">P</span> <span class="o">-</span> <span class="n">Diagonal</span><span class="p">(</span><span class="n">eigenvals</span><span class="p">),</span> <span class="nb">Inf</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="k">end</span>
</span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-julia" data-lang="julia"><span class="line"><span class="cl"><span class="c"># Define the range of n</span>
</span></span><span class="line"><span class="cl"><span class="n">n_values</span> <span class="o">=</span> <span class="mi">2</span><span class="o">:</span><span class="mi">200</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c"># Initialize error arrays for both methods</span>
</span></span><span class="line"><span class="cl"><span class="n">analytic_orth_errors</span> <span class="o">=</span> <span class="kt">Float64</span><span class="p">[]</span>
</span></span><span class="line"><span class="cl"><span class="n">analytic_diag_errors</span> <span class="o">=</span> <span class="kt">Float64</span><span class="p">[]</span>
</span></span><span class="line"><span class="cl"><span class="n">numerical_orth_errors</span> <span class="o">=</span> <span class="kt">Float64</span><span class="p">[]</span>
</span></span><span class="line"><span class="cl"><span class="n">numerical_diag_errors</span> <span class="o">=</span> <span class="kt">Float64</span><span class="p">[]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c"># Compute errors for both methods</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="n">n</span> <span class="k">in</span> <span class="n">n_values</span>
</span></span><span class="line"><span class="cl">    <span class="n">P_analytic</span> <span class="o">=</span> <span class="n">analytic_eigenvecs</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">rts</span><span class="p">,</span> <span class="n">P_numerical</span> <span class="o">=</span> <span class="n">get_eigen</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">push!</span><span class="p">(</span><span class="n">analytic_orth_errors</span><span class="p">,</span> <span class="n">orthonormality_error</span><span class="p">(</span><span class="n">P_analytic</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="n">push!</span><span class="p">(</span><span class="n">analytic_diag_errors</span><span class="p">,</span> <span class="n">diagonal_error</span><span class="p">(</span><span class="n">P_analytic</span><span class="p">,</span> <span class="n">rts</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="n">push!</span><span class="p">(</span><span class="n">numerical_orth_errors</span><span class="p">,</span> <span class="n">orthonormality_error</span><span class="p">(</span><span class="n">P_numerical</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="n">push!</span><span class="p">(</span><span class="n">numerical_diag_errors</span><span class="p">,</span> <span class="n">diagonal_error</span><span class="p">(</span><span class="n">P_numerical</span><span class="p">,</span> <span class="n">rts</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="k">end</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c"># Create 2x2 subplots</span>
</span></span><span class="line"><span class="cl"><span class="n">p1</span> <span class="o">=</span> <span class="n">plot</span><span class="p">(</span><span class="n">n_values</span><span class="p">,</span> <span class="n">log10</span><span class="o">.</span><span class="p">(</span><span class="n">analytic_orth_errors</span><span class="p">),</span> <span class="n">label</span><span class="o">=</span><span class="s">&#34;Analytic&#34;</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s">&#34;Log-scale Orthonormality Error&#34;</span><span class="p">,</span> <span class="n">xlabel</span><span class="o">=</span><span class="s">&#34;n&#34;</span><span class="p">,</span> <span class="n">ylabel</span><span class="o">=</span><span class="s">&#34;Error&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">plot!</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">n_values</span><span class="p">,</span> <span class="n">log10</span><span class="o">.</span><span class="p">(</span><span class="n">numerical_orth_errors</span><span class="p">),</span> <span class="n">label</span><span class="o">=</span><span class="s">&#34;Numerical&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">p2</span> <span class="o">=</span> <span class="n">plot</span><span class="p">(</span><span class="n">n_values</span><span class="p">,</span> <span class="n">log10</span><span class="o">.</span><span class="p">(</span><span class="n">analytic_diag_errors</span><span class="p">),</span> <span class="n">label</span><span class="o">=</span><span class="s">&#34;Analytic&#34;</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s">&#34;Log-scale Diagonalization Error&#34;</span><span class="p">,</span> <span class="n">xlabel</span><span class="o">=</span><span class="s">&#34;n&#34;</span><span class="p">,</span> <span class="n">ylabel</span><span class="o">=</span><span class="s">&#34;Error&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">plot!</span><span class="p">(</span><span class="n">p2</span><span class="p">,</span> <span class="n">n_values</span><span class="p">,</span> <span class="n">log10</span><span class="o">.</span><span class="p">(</span><span class="n">numerical_diag_errors</span><span class="p">),</span> <span class="n">label</span><span class="o">=</span><span class="s">&#34;Numerical&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">plot</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">,</span> <span class="n">layout</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><img alt="Log-scale errors" loading="lazy" src="/images/25-05-02_Hermite-numerics/JL-Hermite_17_0.png"></p>
<p>From the plot we can see that the analytical method is marginally better than the numerical method before $n\approx 170$, but both errors for analytical method blow up after $n\approx 170$, while the numerical method remains stable. The reason for this is that in the analytical method, we need to compute the normalization factor of the Hermite polynomial, which is given by $||\mathrm{He}_n||_{\mathrm{L}^2} = \sqrt{n!}$, and the factorial grows very quickly, eventually blows up at $n\approx 170$.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-julia" data-lang="julia"><span class="line"><span class="cl"><span class="k">for</span> <span class="n">n</span> <span class="k">in</span> <span class="mi">169</span><span class="o">:</span><span class="mi">172</span>
</span></span><span class="line"><span class="cl">    <span class="n">print</span><span class="p">(</span><span class="n">He_norm</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="s">&#34;, &#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="k">end</span>
</span></span></code></pre></td></tr></table>
</div>
</div><pre><code>2.0661723086434517e152, 2.6939590968143674e153, Inf, Inf, 
</code></pre>
<p>This suggests that we can use the analytical method for small $n$, such as $n<50$, where the analytical method diagnoalizes the matrix $\mathrm{T}_n$ more accurately than the numerical method.
In practice, using large $n$ for the Hermite polynomials is not recommended, as there are already numerical instabilities when evaluating the Hermite polynomials.</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="http://localhost:1313/tags/hermite-polynomials/">Hermite Polynomials</a></li>
      <li><a href="http://localhost:1313/tags/numerical-methods/">Numerical Methods</a></li>
    </ul>
<nav class="paginav">
  <a class="next" href="http://localhost:1313/projects/housing-price-prediction-with-xgboost/">
    <span class="title">Next Â»</span>
    <br>
    <span>Housing Price Prediction with XGBoost</span>
  </a>
</nav>

  </footer>
</article>
        <link rel="stylesheet" href="/css/dots-field.css">
        <script src="/js/dots-field.js" defer></script>
        <svg id="dots-field"></svg>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="http://localhost:1313/">Mingyi&#39;s Page</a></span> Â· 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
