[{"content":"I am a PhD student in Mathematics at Uppsala University. My research interests lie in the intersection of probability theory, partial differential equations, and machine learning. I am particularly interested in the mathematical analysis of stochastic processes and their applications in machine learning.\nResearch Publications Preprints M. Hou. Variational Formulation and Capacity Estimates for Non-Self-Adjoint Fokker-Planck Operators in Divergence Form. arXiv preprint, 2025. M. Hou. Boundedness of Weak Solutions to Degenerate Kolmogorov Equations of Hypoelliptic Type in Bounded Domains. arXiv preprint, 2024. B. Avelin, and M. Hou. Weak and Perron\u0026rsquo;s Solutions for Stationary Kramers-Fokker-Planck Equations in Bounded Domains. arXiv preprint, 2024. Published B. Avelin, M. Hou, and K. Nyström. A Galerkin Type Method for Kinetic Fokker-Planck Equations Based on Hermite Expansions. Kinet. Relat. Models, 2024. Contact Department of Mathematics\nUppsala University\n751 06 Uppsala\nSweden\nmingyi.hou@math.uu.se LinkedIn GitHub ","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003eI am a PhD student in Mathematics at Uppsala University. My research interests lie in the intersection of probability theory, partial differential equations, and machine learning. I am particularly interested in the mathematical analysis of stochastic processes and their applications in machine learning.\u003c/p\u003e\n\u003ch2 id=\"research-publications\"\u003eResearch Publications\u003c/h2\u003e\n\u003ch3 id=\"preprints\"\u003ePreprints\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eM. Hou. Variational Formulation and Capacity Estimates for Non-Self-Adjoint Fokker-Planck Operators in Divergence Form. \u003ca href=\"https://arxiv.org/abs/2502.12036\"\u003earXiv preprint, 2025\u003c/a\u003e.\u003c/li\u003e\n\u003cli\u003eM. Hou. Boundedness of Weak Solutions to Degenerate Kolmogorov Equations of Hypoelliptic Type in Bounded Domains. \u003ca href=\"https://arxiv.org/abs/2407.00800\"\u003earXiv preprint, 2024\u003c/a\u003e.\u003c/li\u003e\n\u003cli\u003eB. Avelin, and M. Hou. Weak and Perron\u0026rsquo;s Solutions for Stationary Kramers-Fokker-Planck Equations in Bounded Domains. \u003ca href=\"https://arxiv.org/abs/2405.04070\"\u003earXiv preprint, 2024\u003c/a\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"published\"\u003ePublished\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eB. Avelin, M. Hou, and K. Nyström. A Galerkin Type Method for Kinetic Fokker-Planck Equations Based on Hermite Expansions. \u003ca href=\"https://doi.org/10.3934/krm.2023035\"\u003eKinet. Relat. Models, 2024\u003c/a\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"contact\"\u003eContact\u003c/h2\u003e\n\u003cdiv style=\"display: flex; justify-content: space-between; flex-wrap: wrap;\"\u003e\n  \u003cdiv style=\"flex: 1; min-width: 200px;\"\u003e\n    \u003cp\u003eDepartment of Mathematics\u003cbr\u003e\n    Uppsala University\u003cbr\u003e\n    751 06 Uppsala\u003cbr\u003e\n    Sweden\u003c/p\u003e","title":"About Me"},{"content":"This project implements a Monte Carlo simulation for the Fokker-Planck equation using Metal, a framework for GPU programming on Apple devices. The simulation is designed to model the diffusion of particles in a potential field, which is common in statistical physics and machine learning.\nThe codes are written in Julia and utilize the Metal.jl package to leverage the GPU for parallel computation. You can find the repository for this project here.\nKramers-Fokker-Planck Equation The Kramers-Fokker-Planck equation is the generator of stochastic process modeling a particle\u0026rsquo;s movement in a potential field. The stationary solution of the Fokker-Planck equation is the equilibrium distribution of the particle\u0026rsquo;s position.\nOne example considered in this project is the following SDE: $$ \\begin{cases} \\rm{d}X_t = V_t \\rm{d}t,\\newline \\rm{d}V_t = \\rm{d}B_t, \\end{cases} $$ where $B_t$ is the standard Brownian motion. Denote by $z = (x, v)\\in \\mathbb{R}\\times\\mathbb{R}$. Its generator is given by: $$\\cal{L} = \\frac{1}{2}\\frac{\\partial^2}{\\partial v^2} + v\\frac{\\partial}{\\partial x}.$$\nWe consider the process in the box $Q = (-1, 1)\\times(-1, 1)$, and simulate the process starting at a point $z_0 = (x_0, v_0)\\in Q$ until it hits the boundary of the box.\nThe Monte Carlo simulation involves:\nA Metal kernel function that updates the position of the particle according to the discretized SDE, namely $$ x_{n+1} = x_n + v_n \\Delta t, \\quad v_{n+1} = v_n + \\sqrt{\\Delta t} \\xi_n,$$ where $\\xi_n \\sim \\mathcal{N}(0, 1)$ is the standard normal random variable. Since the Metal kernel does not support random number generation, we also write a simple GPU friendly random number generator based on xorshift32 and Box-Muller method. The Kernel function does not support branching, the iteration will be fixed steps, and we use mask to stop the iteration when the particle hits the boundary. We simulate the process for a large number of particles and plot the harmonic measure on the boundary of the annulus. Features of the Project GPU friendly random number generator The random number generator is based on the xorshift32 algorithm, which is a simple and efficient pseudo-random number generator. The Box-Muller transform is used to generate normally distributed random numbers from uniformly distributed random numbers.\nGiven a seed ranged from 0 to 2^32-1, the xorshift32 algorithm generates a new seed by performing bitwise operations on the current seed.\nfunction xorshift32(seed::UInt32)::UInt32 seed ⊻= (seed \u0026lt;\u0026lt; 13) seed ⊻= (seed \u0026gt;\u0026gt; 17) seed ⊻= (seed \u0026lt;\u0026lt; 5) return seed end Then we transform this seed to a float number in the range of (0, 1) using the following function:\nfunction xorshift32_float(seed::UInt32)::Float32 value = Float32(xorshift32(seed)) * 2.3283064f-10 # Scale to [0,1) return max(value, 1.0f-16) # Ensure it\u0026#39;s in (0,1) end Finally, we use the Box-Muller transform to generate normally distributed random numbers:\nfunction box_muller(u1::Float32, u2::Float32) r = sqrt(-2.0f0 * log(u1)) theta = 2.0f0 * Float32(pi) * u2 return r * cos(theta) end Masks to avoid branching The Metal.jl kernel does not support branching, so we need to avoid using if statements in the kernel code. Instead, we use masks to control the flow of the simulation. The core update function for the problem in the cube $Q$ is as follows:\nfor step in 1:num_steps # Boolean masks for exit conditions mask_x = (x \u0026lt; -1.0f0 || x \u0026gt; 1.0f0) ? 1 : 0 mask_v = (v \u0026lt; -1.0f0 || v \u0026gt; 1.0f0) ? 1 : 0 mask_exit = mask_x | mask_v # Combine masks (exit if either condition is true) continue_mask = 1 - mask_exit # 1 = active, 0 = exited # Generate two uniform distributed random numbers seed1 = xorshift32(seed1) seed2 = xorshift32(seed2) random_number1 = xorshift32_float(seed1) random_number2 = xorshift32_float(seed2) # Generate a normal distributed noise noise = box_muller(random_number1, random_number2) # Perturb the seeds to avoid deterministic patterns seed1 += UInt32(i) seed2 += UInt32(i) # Update position and velocity and store previous state if not exit x_prev, v_prev = continue_mask * x + mask_exit * x_prev, continue_mask * v + mask_exit * v_prev x += continue_mask * (v * time_step) v += continue_mask * (sqrt(time_step) * noise) end The mask_exit variable is used to check if the particle has exited the box. If it has, we set the continue_mask to 0, which effectively stops the simulation for that particle. The x_prev and v_prev variables are used to store the previous state of the particle before it exited.\nExample plots Consider the following Dirichlet boundary condition: Our codes can simulate the solution efficiently. The following plot shows the full solution and also a zoomed-in view of the solution near the singular boundary: In addition, we can plot the exit points distribution on the boundary for a starting point. The following is an example in the annulus: ","permalink":"http://localhost:1313/projects/monte-carlo-kfp-metal/","summary":"\u003cp\u003eThis project implements a Monte Carlo simulation for the Fokker-Planck equation using \u003ccode\u003eMetal\u003c/code\u003e, a framework for GPU programming on Apple devices. The simulation is designed to model the diffusion of particles in a potential field, which is common in statistical physics and machine learning.\u003c/p\u003e\n\u003cp\u003eThe codes are written in \u003ccode\u003eJulia\u003c/code\u003e and utilize the \u003ccode\u003eMetal.jl\u003c/code\u003e package to leverage the GPU for parallel computation. You can find the repository for this project \u003ca href=\"https://github.com/mingyi-ai/Monte_Carlo_KFP\"\u003ehere\u003c/a\u003e.\u003c/p\u003e","title":"Monte Carlo Simulation for Fokker-Planck Equations using Metal"}]